=== README ETAPA 1 ===
Proiect PROIECTAREA ALGORITMILOR
Echipa DUMB.BLONDES (grupa 323CB)

MEMBRII:	BADITA Rares-Octavian(capitan)
			GHERASIE Stefania-Elena
			MANDRU Cosmina



== INSTRUCTIUNI DE COMPILARE

Makefile-ul contine urmatoarele reguli:
	default - realizeaza fisierul cu extensia .jar
	make jar - realizeaza fisierul cu extensia .jar
	make run - face fisierul .jar si il ruleaza 
	make xboard - face fisierul .jar si il pune ca fcp pentru XBoard
	make clean - sterge fisierele .class

Pentru rularea temei in cadrul XBoard-ului se poate folosi "make xboard".
Se recomanda rularea "make clean" pentru testari repetate.



== DETALII DESPRE STRUCTURA PROIECTULUI

Proiectul presupune realizarea reprezentarii internă a tablei de joc și a pieselor de joc, precum și o interfațare cu programul XBoard.
Interfațarea va presupune posibilitatea de a interpreta și interacționa cu următoarele comenzi ale XBoard: xboard, new, force, go, white, black, quit, resign, move.

Proiectul este implementat in Java si urmareste interactiune cu XBoard-ul.
Am realizat 4 pachete pentru structurarea claselor(main, commands, pieces,
auxiliary).

					-- pachetul "main" --
Am creat clasa ChessBoard pentru reprezentarea interna a tablei de sah. Am
folosit Design Pattern-ul Singleton pentru a asigura unicitatea tablei, 
creearea instantei facandu-se prin apelarea metodei getInstance(). Tabla este
reprezentata sub forma unei matrici 8x8 de piese. Variabilele playingColor, 
playerTurn sunt folosite pentru a retine ce culoare joaca si ce culoare urmeaza
sa mute. Variabila forceMode este folosita pentru comanda Force.
Aceasta clasa contine metode pentru resetarea tablei la pozitia initiala,
obtinerea unei piese in functie de pozitie si metode de set si get pentru
variabile.

Clasa ChessMain ruleaza programul. Se creeaza o tabla si se citesc comenzile 
de la XBoard. Se porneste jocul,care pentru aceasta etapa se rezuma la miscarea
pionilor pe tabla prin generare aleatorie a miscarilor. Se dau XBoard-ului
miscari random. Aceasta parte de cod urmeaza a fi inlocuita pentru etapele viitoare.

					-- pachetul "pieces" --
Reprezentarea pieselor porneste de la clasa abstracta AbstractPiece. Piesele
sunt caracterizate prin pozitie si culoare. Constructorul clasei asigneaza 
pozitia si culoarea. Se definesc si metodele getPossibleMoves, verifyMove,
move pentru realizarea mutarilor.

Pentru a reprezenta locul liber pe tabla se foloseste clasa VoidPiece care este
o piesa nula care ajuta la mutari.

Am creat clase pentru fiecare tip de piesa(Pawn, Bishop, King, Knight, Queen,
Rook) si am implementat miscarile doar pentru pion, celelalte piese urmand sa
fie realizate in etapele viitoare. S-a facut un PieceFactory pentru realizarea 
de piese corespunzatoare tinand cont de pozitie, folosind Design Pattern-ul Factory.

Clasa Pawn extinde clasa AbstactPiece si implementeaza metoda getPossibleMoves.
Se salveaza intr-un ArrayList pozitiile mutarilor posibile, tinand cont de 
mutarile legale ale pionului si de marginile tablei. Mutarile se realizeaza
tinand cont de culoarea jucata, de pozitiile ocupate pe tabla, de locurile
libere. Metoda move() plaseaza piesa pe pozitia data.

					-- pachetul "commands" --
S-a creat clasa Command care reprezinta comenzile continand metoda execute().
Aceasta clasa va fi mostenita pentru individualizarea comenzilor. Clasa 
VoidCommand reprezinta o comanda nula.

S-au creat clase pentru fiecare comanda specificata in cerinta(xboard, new, 
force, go, white, black, quit, resign si protover). Fiecare comanda respecta
specificatiile mentionate in documentatie.

					-- pachetul "auxiliary" --
Se foloseste clasa Position pentru a reprezenta pozitia pe tabla a unei piese.
Aceasta contine metode pentru a corela pozitia data sub forma de String cu 
matricea prin care este reprezentata tabla de joc. S-au mai utilizat metode
care testeaza daca pozitiile date ca parametru sunt legale.

PieceFactory foloseste Design Pattern-ul factory pentru generarea de piese in 
functie de pozitie.

CommandFactory utilizeaza Design Pattern-ul factory pentru a construi comenzi
in functie de argumentul primit la citire.

CommandReader este folosit pentru citirea de la stdin a comenzilor. Se
proceseaza pe rand comenzile si se asigura prelucrarea argumentelor primite de
la XBoard.



== DETALII DESPRE ABORDAREA ALGORITMICA A ETAPEI

Aceasta etapa nu a presupus utilizarea algoritmilor studiati in cazul cursului
de Proiectarea Algoritmilor, prin urmare nu s-au folosit algoritmi specifici.



== RESPONSABILITATEA FIECARUI MEMBRU DIN ECHIPA

Deoarece dificultatea principala a acestei etape a fost descoperirea unei
metode de interactiune cu XBoard-ul, am lucrat impreuna pentru a ne familiariza
cu engine-ul de XBoard si a decide ce structura sa abordam pentru implementarea
proiectului.

Am pornit prin a structura un schelet de cod, care a fost apoi dezvoltat
individual si in echipa pentru a se potrivi cerintelor proiectului. 
Pentru a da exemplu de responsibilitati individuale, Rares s-a ocupat de 
crearea tablei, a pozitiilor si a piesei implementate(pion), citirea comenzilor, Cosmina de implementarea comenzilor si Stefania de generarea
aleatorie a miscarilor si realizarea unui ReadMe.
Fiecare membru a incercat sa contribuie la proiect, mai ales in rezolvarea
erorilor si problemelor care au aparut.



== SURSE DE INSPIRATIE

[1] - https://www.gnu.org/software/xboard/
[2] - https://www.gnu.org/software/xboard/engine-intf.html
[3] - https://www.howtoforge.com/tutorial/xboard-add-chess-engines/
[4] - https://stackoverflow.com/questions/22060432/how-to-make-a-simple-protocol-to-winboard
[5] - https://codereview.stackexchange.com/questions/194736/chess-application-in-java
[6] - https://stackoverflow.com/questions/9556577/communicating-with-xboard-chess-engine-c-c


== ADAUGARI

Codul contine functii care au fost utilizate pentru testare si care
ar putea fi utile in realizarea etapelor viitoare. De aceea, am ales sa
le pastram. Aceastea nu incurca insa testarea programului pentru aceasta 
etapa.